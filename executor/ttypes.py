#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import general.ttypes

from thrift.transport import TTransport
all_structs = []


class ExecuteByteCodeResult(object):
    """
    Attributes:
     - status
     - contractState
     - ret_val

    """


    def __init__(self, status=None, contractState=None, ret_val=None,):
        self.status = status
        self.contractState = contractState
        self.ret_val = ret_val

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = general.ttypes.APIResponse()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.contractState = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ret_val = general.ttypes.Variant()
                    self.ret_val.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteByteCodeResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.contractState is not None:
            oprot.writeFieldBegin('contractState', TType.STRING, 2)
            oprot.writeBinary(self.contractState)
            oprot.writeFieldEnd()
        if self.ret_val is not None:
            oprot.writeFieldBegin('ret_val', TType.STRUCT, 3)
            self.ret_val.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetterMethodResult(object):
    """
    Attributes:
     - status
     - ret_val

    """


    def __init__(self, status=None, ret_val=None,):
        self.status = status
        self.ret_val = ret_val

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = general.ttypes.APIResponse()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ret_val = general.ttypes.Variant()
                    self.ret_val.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetterMethodResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.ret_val is not None:
            oprot.writeFieldBegin('ret_val', TType.STRUCT, 2)
            self.ret_val.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteByteCodeMultipleResult(object):
    """
    Attributes:
     - status
     - results

    """


    def __init__(self, status=None, results=None,):
        self.status = status
        self.results = results

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = general.ttypes.APIResponse()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.results = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = GetterMethodResult()
                        _elem5.read(iprot)
                        self.results.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteByteCodeMultipleResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.results is not None:
            oprot.writeFieldBegin('results', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.results))
            for iter6 in self.results:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetContractMethodsResult(object):
    """
    Attributes:
     - status
     - methods

    """


    def __init__(self, status=None, methods=None,):
        self.status = status
        self.methods = methods

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = general.ttypes.APIResponse()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.methods = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = general.ttypes.MethodDescription()
                        _elem12.read(iprot)
                        self.methods.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetContractMethodsResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.methods is not None:
            oprot.writeFieldBegin('methods', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.methods))
            for iter13 in self.methods:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetContractVariablesResult(object):
    """
    Attributes:
     - status
     - contractVariables

    """


    def __init__(self, status=None, contractVariables=None,):
        self.status = status
        self.contractVariables = contractVariables

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = general.ttypes.APIResponse()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.contractVariables = {}
                    (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
                    for _i18 in range(_size14):
                        _key19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val20 = general.ttypes.Variant()
                        _val20.read(iprot)
                        self.contractVariables[_key19] = _val20
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetContractVariablesResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.contractVariables is not None:
            oprot.writeFieldBegin('contractVariables', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.contractVariables))
            for kiter21, viter22 in self.contractVariables.items():
                oprot.writeString(kiter21.encode('utf-8') if sys.version_info[0] == 2 else kiter21)
                viter22.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CompileSourceCodeResult(object):
    """
    Attributes:
     - status
     - byteCodeObjects

    """


    def __init__(self, status=None, byteCodeObjects=None,):
        self.status = status
        self.byteCodeObjects = byteCodeObjects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = general.ttypes.APIResponse()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.byteCodeObjects = []
                    (_etype26, _size23) = iprot.readListBegin()
                    for _i27 in range(_size23):
                        _elem28 = general.ttypes.ByteCodeObject()
                        _elem28.read(iprot)
                        self.byteCodeObjects.append(_elem28)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CompileSourceCodeResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.byteCodeObjects is not None:
            oprot.writeFieldBegin('byteCodeObjects', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.byteCodeObjects))
            for iter29 in self.byteCodeObjects:
                iter29.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExecuteByteCodeResult)
ExecuteByteCodeResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [general.ttypes.APIResponse, None], None, ),  # 1
    (2, TType.STRING, 'contractState', 'BINARY', None, ),  # 2
    (3, TType.STRUCT, 'ret_val', [general.ttypes.Variant, None], None, ),  # 3
)
all_structs.append(GetterMethodResult)
GetterMethodResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [general.ttypes.APIResponse, None], None, ),  # 1
    (2, TType.STRUCT, 'ret_val', [general.ttypes.Variant, None], None, ),  # 2
)
all_structs.append(ExecuteByteCodeMultipleResult)
ExecuteByteCodeMultipleResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [general.ttypes.APIResponse, None], None, ),  # 1
    (2, TType.LIST, 'results', (TType.STRUCT, [GetterMethodResult, None], False), None, ),  # 2
)
all_structs.append(GetContractMethodsResult)
GetContractMethodsResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [general.ttypes.APIResponse, None], None, ),  # 1
    (2, TType.LIST, 'methods', (TType.STRUCT, [general.ttypes.MethodDescription, None], False), None, ),  # 2
)
all_structs.append(GetContractVariablesResult)
GetContractVariablesResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [general.ttypes.APIResponse, None], None, ),  # 1
    (2, TType.MAP, 'contractVariables', (TType.STRING, 'UTF8', TType.STRUCT, [general.ttypes.Variant, None], False), None, ),  # 2
)
all_structs.append(CompileSourceCodeResult)
CompileSourceCodeResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [general.ttypes.APIResponse, None], None, ),  # 1
    (2, TType.LIST, 'byteCodeObjects', (TType.STRUCT, [general.ttypes.ByteCodeObject, None], False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
